# <tk> 

c++事件驱动模拟库，作为一个实验项目,见[手册][1]以及[报告][2]，主要目的是供大家学习交流。

# 摘要

与Lua、Simula67不同，c++目前没有相应的语言机制来支持方便地定义协程，而是依赖一些专门的库，比如<boost/coroutine2>。不过，这种情况也正在发生改变。协程的实现，或是利用显式操作在协程之间转移控制权；或是在调用结束后隐式地将控制权交还给调用者。相应地，使用前者的协程称为对称的，后者为非对称的。两种方式都依赖于一种调用场景切换的基础性技术。利用协程的概念，可以反过来实现迭代器、生成器等组件，也可以把它扩展为一个多任务系统（有人把这里的任务称作纤维，可以把“纤维程序”理解为带有自动调度机制的协程）。有些程序，可以很自然地用一组既能相互独立运作又能保持通信以达成统一目标的简单活动来表示。这里把它称作任务的活动，有着自己的独立控制、例行程序、私有数据，任务之间可以通过共享数据、消息或者管道进行通信。<task>是作为c++早期编译器cfront里面的一个古老的多任务模拟库，其最初版本是Bjame Stroustrop博士在AT&T的贝尔实验室完成的。<task>秉承优雅的设计语言，然而它依赖于汇编语言来实现核心的场景切换技术，这决定了它无法跨平台使用；另一方面，由于它完成时间很早，也就没能很好利用后来c++发展出来的虚函数、模板等机制。

<tk>致力于成为<task>的继任者，以新技术实现其核心框架，并使其拥有跨平台的能力。为此<tk>引入文章提到的<Coroutine>协程库使用的一种共享运行时栈的技术，该技术以递归函数为媒介，利用标准库里面的<setjmp.h>包和称为控制块的数据结构分配、使用、管理运行时栈，来实现调用场景切换功能。这也是现今c++库实现协程的主流技术。<tk>对<Coroutine>的相关代码进行了重构，以精简代码，提高代码可阅读性和可维护性，主要的努力包括：1） 把控制块相关功能全部集中到核心递归函数里面，以至于可以对主函数任务做更好的封装；2）控制块数据封装；3）setjmp/longjmp显式调用标记。此外，为了支持任务的中途取消功能（可以简化用户任务逻辑、等等），控制块在占用、空闲之外新增了废弃的状态，处于废弃状态的控制块在一定条件下可以回收。最后，系统加入如了简单有效的栈溢出检测机制。

# 参考资料

[1]: <https://zhuanlan.zhihu.com/p/88028766> "（用户指南）使用<tk>做事件驱动模拟"
[2]: <https://zhuanlan.zhihu.com/p/88758535> "（技术报告）<tk>:一个可移植的c++事件驱动模拟库"
